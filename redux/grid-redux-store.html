<link rel="import" href="../bower_components/polymer-redux/polymer-redux.html">

<script>



  const API_BASE_URL = (location.hostname == 'dev.thegrid.com') ? 'https://api.thegrid.com' : 'https://dev-thegrid.azurewebsites.net';
  // const API_BASE_URL = 'https://dev.thegrid.com';
  const API_URL = API_BASE_URL + '/api';
  // const APP_URL = 'http://10.0.0.10:8080/#/';
  const APP_URL = '/';
  const HOME_URL = APP_URL;
  const LOGIN_URL = APP_URL + 'login';
  const REGISTER_URL = APP_URL + 'register';
  const FORGOT_URL = APP_URL + 'forgot';
  const PROFILE_URL = APP_URL + 'profile';
  const VERIFY_URL = APP_URL + 'verification';
  const SETUP_URL = APP_URL + 'profile/setup';

  const intialState = {
    user: null,
    token: null,
    auth: false,
    skills: [],
    posts: [],
    bids: [],
    inbox: [],
    unreadMessages: 0,
    r_markers: null,
    notifications: []
  };

  const reducer = (state, action) => {
    if( !state ) return intialState;
    switch (action.type) {

      case 'LOGGED_USER': {
        const user = action.user;
        return Object.assign({}, state, { user: user, auth: true } );
        break;
      }
      case 'UPDATE_USER': {
        const user = action.user;
        window.localStorage.setItem('user', JSON.stringify(user));
        return Object.assign({}, state, { user: user } );
        break;
      }
      case 'LOGOUT_USER': {
        return Object.assign({}, state, { user: null, auth: false, token: null, skills: null } );
        break;
      }
      case 'ASSIGN_TOKEN': {
        const token = action.token;
        return Object.assign({}, state, { token: token });
        break;
      }
      case 'GIVE_ACCESS': {
        const _token = action.token;
        const _user = action.user;
        return Object.assign({}, state, { token: _token, user: _user, auth: true });
        break;
      }
      case 'SET_SKILLS': {
        const _skills = action.skills;
        return Object.assign({}, state, { skills: _skills });
        break;
      }
      case 'ADD_SKILL': {
        var skills = state.skills.slice(0);
        skills.push(action.skill);
        return Object.assign({}, state, { skills: skills });
        break;
      }
      case 'REMOVE_SKILL': {
        var skills = state.skills.slice(0);
        skills.splice(skills.indexOf(action.skill), 1);
        return Object.assign({}, state, { skills: skills });
        break;
      }
      case 'SET_POSTS': {
        return Object.assign({}, state, {
          posts: action.posts
        });
        break;
      }
      case 'ADD_POST': {
        let user = JSON.parse(JSON.stringify(state.user));
        let posts = state.posts.slice(0);
        posts.unshift(action.post);
        user.jobs_count += 1;
        return Object.assign({}, state, {
          posts: posts,
          user: user
        });
        break;
      }
      case 'UPDATE_POST': {
        let posts = state.posts.slice(0);
        const updatedPosts = posts.map(item => {
          if(item.id === action.post.id){
            return action.post;
          }
          return item
        });
        return Object.assign({}, state, {
          posts: updatedPosts
        });
        break;
      }
      case 'SET_BIDS': {
        return Object.assign({}, state, {
          bids: action.bids
        });
        break;
      }
      case 'ADD_BID': {
        let bids = state.bids.slice(0);
        let user = JSON.parse(JSON.stringify(state.user));
        bids.unshift(action.bid);
        user.bids_count += 1;
        return Object.assign({}, state, {
          bids: bids,
          user: user
        });
        break;
      }
      case 'UPDATE_BID': {
        console.log('updating bid..', action.bid);
        let bids = state.bids.slice(0);
        const updatedBids = bids.map(item => {
          if(item.id === action.bid.id){
            return action.bid;
          }
          return item
        });
        return Object.assign({}, state, {
          bids: updatedBids
        });
        break;
      }
      case 'UPDATE_BIDDERS': {
        let bids = state.bids.slice(0);

        var bid = bids.find(item => {
          return item.id == action.id;
        });

        // console.log('found bid is', bid);

        bid.job.only_bids = action.bidders;

        console.log('updated bid is', bid);

        const updatedBids = bids.map(item => {
          if(item.id === action.id){
            return bid;
          }
          return item
        });

        return Object.assign({}, state, {
          bids: updatedBids
        });
        break;
      }
      case 'SET_INBOX': {
        return Object.assign({}, state, {
          inbox: action.inbox
        });
        break;
      }
      case 'ADD_INBOX': {
        let inbox = state.inbox.slice(0);
        inbox.unshift(action.conversation);
        return Object.assign({}, state, {
          inbox: inbox,
        });
        break;
      }
      case 'ADD_MESSAGE': {
        let inbox = state.inbox.slice(0);
        
        var conversation = inbox.find(item => {
          return item.id == action.id;
        });

        const _conversation = action.message.conversation;

        if(_conversation && conversation) {
          console.log('is conversation', _conversation);
          conversation.last_updated_by = Number(_conversation.last_updated_by);
          conversation.unread_count = Number(_conversation.unread_count);
          conversation.updated_at = _conversation.updated_at;

          delete action.message.conversation;
        }

        conversation.messages.push(action.message);

        const updatedInbox = inbox.map(item => {
          if(item.id == action.id){
            return conversation;
          }
          return item
        });

        return Object.assign({}, state, {
          inbox: updatedInbox,
        });
        break;
      }
      case 'UPDATE_CONVERSATION': {
        let inbox = state.inbox.slice(0);
        console.log('updating conversation');
        
        var conversation = inbox.find(item => {
          return item.id == action.id;
        });

        const _conversation = action.conversation;

        if(_conversation && conversation) {

          conversation.last_updated_by = Number(_conversation.last_updated_by);
          conversation.unread_count = Number(_conversation.unread_count);
          conversation.updated_at = _conversation.updated_at;

        }

        const updatedInbox = inbox.map(item => {
          if(item.id == action.id){
            return conversation;
          }
          return item
        });

        return Object.assign({}, state, {
          inbox: updatedInbox,
        });
        break;
      }
      case 'SET_UNREAD_MESSAGES': {
        let user = JSON.parse(JSON.stringify(state.user));
        
        user.unread_messages_count = action.unreadMessages;
        return Object.assign({}, state, { user: user });
        break;
      } 
      case 'SET_MARKERS': {
        return Object.assign({}, state, { r_markers: action.markers });
        break;
      }
      case 'ADD_MARKER': {
        var markers = state.r_markers.slice(0);
        console.log(action.marker);
        markers.push(action.marker);
        return Object.assign({}, state, { r_markers: markers });
        break;
      }
      case 'SET_NOTIFCATIONS': {
        return Object.assign({}, state, {
          notifications: action.notifications
        });
        break;
      }
    }
  };

  const _store = Redux.createStore(
    reducer,
    Redux.applyMiddleware(ReduxThunk.default)
  );

  const ReduxBehavior = PolymerRedux(_store);

  const ReduxAsyncActionBehavior = superclass => class extends superclass {

    static get actions() {
      return {

        loggedUser(user) {
          return {
            type: 'LOGGED_USER',
            user: user
          }
        },

        updateUser(user) {
          return {
            type: 'UPDATE_USER',
            user: user
          }
        },

        logout() {
          return {
            type: 'LOGOUT_USER'
          }
        },

        setSkills(skills) {
          return {
            type: 'SET_SKILLS',
            skills: skills
          }
        },

        // posts
        setPosts(posts) {
          return {
            type: 'SET_POSTS',
            posts: posts
          }
        },

        addPost(post) {
          return {
            type: 'ADD_POST',
            post: post
          }
        },
        
        updatePost(post) {
          return {
            type: 'UPDATE_POST',
            post: post
          }
        },

        // bids
        setBids(bids) {
          return {
            type: 'SET_BIDS',
            bids: bids
          }
        },
        
        addBid(bid) {
          return {
            type: 'ADD_BID',
            bid: bid
          }
        },

        updateBid(bid) {
          return {
            type: 'UPDATE_BID',
            bid: bid
          }
        },
        
        updatedBidders(id, bidders) {
          return {
            type: 'UPDATE_BIDDERS',
            id: id,
            bidders: bidders
          }
        },

        // inbox
        setInbox(inbox) {
          return {
            type: 'SET_INBOX',
            inbox: inbox
          }
        },

        addInbox(conversation) {
          return {
            type: 'ADD_INBOX',
            conversation: conversation
          }
        },

        addMessage(id, message) {
          return {
            type: 'ADD_MESSAGE',
            id: id,
            message: message
          }
        },

        addConversation(conversation) {
          return {
            type: 'UPDATE_CONVERSATION',
            conversation: conversation
          }
        },

        setUnreadMessages(unreadMessages) {
          return {
            type: 'SET_UNREAD_MESSAGES',
            unreadMessages: unreadMessages
          }
        },

        updateConversation(id, conversation) {
          return {
            type: 'UPDATE_CONVERSATION',
            id: id,
            conversation: conversation
          }
        },

        setNotifications(notifications) {
          return {
            type: 'SET_NOTIFCATIONS',
            notifications: notifications
          }
        }

      }
    }
  };

  window.gAxios = null;

  checkLogin = () => {
    if( localStorage.getItem('token') ) {

      // const access_token = JSON.parse(localStorage.getItem('token'))['access_token'];
      const access_token = localStorage.getItem('token');

      if(access_token) {

        gAxios = axios.create({
          baseURL: API_URL,
          headers: {
            'Authorization': 'Bearer ' + access_token
          }
        });
        return true;
      }
      return false;
    }
    return false;
  }

  checkLogin();

  redirect = url => {
    if( ! url ) return;
    // window.location.href = url;
    window.history.pushState({}, null, url);
    window.dispatchEvent(new CustomEvent('location-changed'));
  }

</script>
