<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/paper-toast/paper-toast.html">
<link rel="import" href="../../../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../../../behaviors/map-behavior.html">
<link rel="import" href="../../../behaviors/navigation-behavior.html">
<link rel="import" href="../grid-styles.html">

<dom-module id="grid-map">
  <template>
    <style include="grid iron-flex">

      :host {
        display: block;
        width: 100%;
        height: 100%;
        padding-top: 47px; /* to exclude what is not visible to user */
      }

      :host(.selecting) {
				position: absolute;
				top: 0;
				right: 0;
				bottom: 0;
				left: 0;
				z-index: 98;
			}

      #mapCanvas {
        height: 100%;
        width: 100%;
        background-color: #2b2b2b;
      }

      /* a[href^="http://maps.google.com/maps"],
      a[href^="https://maps.google.com/maps"],
      a[href^="https://www.google.com/maps"] {
          display: none !important;
      } */
      .gmnoprint:not(.gm-bundled-control), .gmnoscreen {
          display: none;
      }
      .gm-bundled-control .gmnoprint {
          display: block;
      }

      #searchResultToast paper-button {
        text-transform: none;
      }


    </style>

    <div id="mapCanvas">

      <div class="overlay" style="background: #212121;">
        <div class="align-center">
          <paper-spinner active></paper-spinner>
        </div>
      </div>

    </div>

    <paper-toast id="searchResultToast" duration="0" class="-fit-bottom" horizontal-align="right" vertical-align="top">
      <div class="block align-right" style="margin-right: -24px; margin-bottom: -16px; margin-top: 16px;">
        <paper-button class="red" on-click="closeSearchResultToast">Close</paper-button>
        <paper-button class="red" on-click="closeSearchResult">View all</paper-button>
      </div>
    </paper-toast>

  </template>

  <script>

    class GridMap extends GridNavigation(MapBehaviorMixin(ReduxBehavior(Polymer.Element))) {

      static get is() { return 'grid-map'; }

      static get properties() {
        return {

          apiKey: {
            type: String,
            value: 'AIzaSyAJyuWvZ03O18yHTvC1t3Mlj22VY73hJWc'
          },

          user: {
            type: Object,
            statePath: 'user'
          },

          auth: {
            type: Boolean,
            statePath: 'auth'
          },

          cluster: {
            type: Boolean,
            value: true
          },

          r_markers: {
            type: Object,
            statePath: 'r_markers'
          },

          gmap: {
						type: Object,
						value: function () {
							return this;
						},
						notify: true
          }

        }

      }

      static get observers() {
        return [
          '_authChange(auth)',
          // '_markersChange(markers)'
        ]
      }

      static get actions() {
  			return {
          setMarkers(markers) {
            return {
              type: 'SET_MARKERS',
              markers: markers
            }
          },

          r_addMarker(marker) {
            return {
              type: 'ADD_MARKER',
              marker: marker
            }
          }
  			};
      }
      
      get searchResultToast() {
        return this.shadowRoot.querySelector('#searchResultToast');
      }

      constructor() {
        super();
        const self = this;

        this._initSocketEvents();

        window.addEventListener('user:connected', e => {
          this.populateJobMarkers();
        });
        
        window.addEventListener('offline', () => {
          this.loadingJobMarkers = false;
        });

        window.addEventListener('filter', e => {
          console.log(e.detail);
          // this.paintMarkers(e.detail);
        });

        let last_location = localStorage.getItem('last_location');

        if(last_location) {
          last_location = JSON.parse(last_location);
          const center = new google.maps.LatLng(last_location.lat, last_location.lng);
          this.mapOptions.center.lat = last_location.lat;
          this.mapOptions.center.lng = last_location.lng;
        }

      }

      connectedCallback() {
        super.connectedCallback();

        const self = this;

        //self.loadGoogleApi('https://maps.googleapis.com/maps/api/js?key=' + self.apiKey + '&libraries=places', function() {
          self.loadMapCanvas();
          if( self.cluster ) {
            //self.loadGoogleApi('/assets/js/markerclusterer.js',
              //function() {
                  self.markerClusterer = new MarkerClusterer(self.map, [], self.clusterOptions);
             // }
           // );
          }
          self.loadGoogleApi('https://cdnjs.cloudflare.com/ajax/libs/OverlappingMarkerSpiderfier/1.0.3/oms.min.js',
            function() {
              self.oms = new OverlappingMarkerSpiderfier(self.map, {
                markersWontMove: true,   // we promise not to move any markers, allowing optimizations
                markersWontHide: true,   // we promise not to change visibility of any markers, allowing optimizations
                basicFormatEvents: true  // allow the library to skip calculating advanced formatting information
              });
            }
          )
       // });

      }

      openSearchResultToast(text) {
        this.searchResultToast.text = text;
        this.searchResultToast.fitInto = this;
        this.searchResultToast.open();
      }

      closeSearchResult() {
        this.populateJobMarkers();
        this.redirectHome();
        this.searchResultToast.toggle();
      }

      closeSearchResultToast() {
        this.searchResultToast.toggle();
      }

      loadMapCanvas() {
        let e = this.$.mapCanvas;
        let options = this.mapOptions;

        this.map = new google.maps.Map(e, options);
        this.map.setOptions({ zoomControlOptions: { position: google.maps.ControlPosition.LEFT_BOTTOM } });

        this.setMapCenter(this.map);
        
        if(window.mobilecheck()) {
          this.map.setOptions({zoomControl: false});
        }
        this.listenMapEvents();
        this.populateJobMarkers();
      }

      setMapCenter(map) {
        if(!window.localStorage) return;
        let last_location = localStorage.getItem('last_location');
        if(last_location) {
          last_location = JSON.parse(last_location);
          const center = new google.maps.LatLng(last_location.lat, last_location.lng);
          map.setCenter(center);
        }
      }

      listenMapEvents() {
        const self = this;

        this.mapListener('center_changed', function() {

          if(self.gmap.currentLocation && self.gmap.map.getBounds()) {
            if(this.map.getBounds().contains(self.gmap.currentLocation.latlng)) {
              window.dispatchEvent(new CustomEvent('map:current_location_in_bounds'));
            } else {
              window.dispatchEvent(new CustomEvent('map:current_location_out_bounds'));
            }
          }

          if(!self.classList.contains('selecting')) return;

          let detail = {
            lat: this.map.getCenter().lat(),
            lng: this.map.getCenter().lng(),
            location: ';;;'
          };
          window.dispatchEvent(new CustomEvent('map:center_changed', { detail: detail} ));
        });
      }

      paintMarkers(data, bounded = false) {

        this.removeAllMarkers();

        // setTimeout(() => {
          let markerType = this.markerType.newJob;

          let bounds = null;

          if(bounded) {
            bounds = new google.maps.LatLngBounds();
          }

          for(var i = 0; i < data.length; i++) {
            markerType = this.markerType.newJob;
            data[i].fillColor = markerType.color;
            data[i].isMyPost = false;
            data[i].isBidded = false;
            data[i].isAwarded = false;
            data[i].hasWinner = false;
            var bids = data[i].bids;

            if(this.auth) {
              if(this.user.id == data[i].user_id) {
                markerType = this.markerType.myJob;
                data[i].fillColor = markerType.color;
                data[i].isMyPost = true;
              }
              if(data[i].winner) {
                data[i].hasWinner = true;
                if(this.user.id == data[i].winner.user_id) {
                  data[i].isAwarded = true;
                }
              }
              for(var j = 0; j < bids.length; j++) {
                // Check if user is already bidded
                if(this.user.id == bids[j].user_id) {
                  markerType = this.markerType.biddedJob;
                  data[i].fillColor = markerType.color;
                  data[i].isBidded = true;
                }
              }
            }

            if( data[i].hasWinner && !data[i].isAwarded && !data[i].isMyPost) {
              continue;
            }

            // IDEA: remove existing marker before adding it
            // this.removeBy( _marker => {
            //   return _marker.id === data[i].id;
            // });

            const duplicateMarker = this.findBy( m => {
              return (m.lat == data[i].lat && m.lng == data[i].lng);
            });

            if(duplicateMarker.length) {
              const offsetPositon = this.offsetMarker(data[i].lat, data[i].lng, 2);
              data[i].lat = offsetPositon.lat;
              data[i].lng = offsetPositon.lng;
            }
 
            this._newMarker(data[i]);

            if(bounded) {
              let position = new google.maps.LatLng(data[i].lat, data[i].lng);
              bounds.extend(position);
            }  
            
          }

          if(bounded) {
            this.map.fitBounds(bounds);
          }

          this.gmap.markerClusterer.repaint();
          
        // }, 1000);
        
      }

      populateJobMarkers(bounds = true) {
        // IDEA: if map is currently loading do nothing to prevent multiple request at once
        if( this.loadingJobMarkers ) return;

        const self = this;
        var markers = self.markers;

        self.loadingJobMarkers = true;

        let _axios = axios;
        let url = `${this.url.API_BASE_URL}/job/all?lat=${self.mapOptions.center.lat}&lng=${self.mapOptions.center.lng}`

        if(this.auth) {

          _axios = gAxios;
          url = `/users/job/all?lat=${self.mapOptions.center.lat}&lng=${self.mapOptions.center.lng}`
        }

        const getLiveData = () => {
          return _axios.get(url, {
            headers: {}
          }).catch(function(){
            return null;
          });
        };

        const getChachedData = () => {
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            return _axios.get(url, {
              headers: { 'Cached': 'yes'}
            }).catch(function(){
              return null;
            });
          } else {
            return Promise.resolve(null);
          }
        }

        const liveData = getLiveData().then(res => {
          if(!res) return false;
          if(res.data) {
            setTimeout( () => {
              this.paintMarkers(res.data, bounds);
            }, 200);
            return true;
          }
          return false;
        });

        const cacheData = getChachedData().then(res => {
          if(!res) return false;
          if(res.data) {
            this.paintMarkers(res.data, bounds);
            return true;
          }
          return false;
        });

        liveData.then( fetched => {
          return fetched || cacheData;
        }).then( dataFetched => {
          if(!dataFetched) {
            // 
          }
          this.loadingJobMarkers = false;
        });

      }

      _markersChange(markers) {
        if(!markers) return;
        // console.log(markers);
        // for(var i = 0; i < markers.length; i++) {
        //   this._newMarker(markers[i]);
        // }
      }

      newMarker(data) {
        this._newMarker(data);
      }

      offsetMarker(lat, lng, m = 2) {
        lat = Number(lat);
        lng = Number(lng);

        const r = 6378137;
        const offset = m;

        const offsetLat = offset/r;
        const offsetLng = offset/(r*Math.cos(Math.PI*lat/180));

        return {
          lat: lat + offsetLat * 180/Math.PI,
          lng: lng + offsetLng * 180/Math.PI
        };
      }

      updateMarker(data) {
        if(!window.google || !data) return;

        var new_marker_position = new google.maps.LatLng(data.lat, data.lng);

        const markers = this.findBy( marker => {
          return marker.id == data.id;
        });

        if(markers.length) {
          markers[0].setPosition(new_marker_position);
        }
        
      }

      _newMarker(data) {
				var self = this;
				var customPin = {
					path: 'M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z',
					fillColor: data.fillColor,
					fillOpacity: 1,
					scale: 1.5,
					strokeColor: data.fillColor,
					strokeWeight: 0.5,
					width: 36,
					height: 36
				};
				var svg = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="'+customPin.width+'" height="'+customPin.height+'"><path transform="scale('+customPin.scale+')" fill="'+customPin.fillColor+'" stroke="'+customPin.strokeColor+'" stroke-width="'+customPin.strokeWeight+'" d="'+customPin.path+'"/></svg>';
				// var d = JSON.stringify(data),
				// 	content = document.createElement('grid-info-window');
				// content.data = d;
				// content.isMyPost = data.isMyPost;
        // content.isBidded = data.isBidded;

        var content = data.name + '<br/>' + 'AED ' + data.price;

        var icon = '/assets/images/icons/unrelated-marker.svg';

        if( data.isBidded || data.isMyPost ) {
          icon = '/assets/images/icons/related-marker.svg';
        }

        if(data.isAwarded) {
          icon = '/assets/images/icons/awarded-marker.svg';
        }

				// var dups = self.findBy( marker => {
				// 	return (marker.lat == data.lat) && (marker.lng == data.lng);
				// });

        var post_url = (username, post_id) => {
          return '/@' + username + '/posts/' + post_id; 
        };

        var _icon = {
          url: icon,
          //labelOrigin: new google.maps.Point(10, 40)
        }

				self.addMarker({
          id: data.id,
          category: data.category_id,
          currency: 'AED',
					price: 'AED ' + data.price,
          date: data.date,
          distance: data.distance || null,
					isBidded: data.isBidded,
					isMyPost: data.isMyPost,
					lat: parseFloat(data.lat),
					lng: parseFloat(data.lng),
					icon: _icon,
          user: data.user,
					// content: content,
					events: [
						{
							name: 'spider_click',
							callback: function(e, obj) {
                window.dispatchEvent(new CustomEvent('app:title_change', { detail: { title: `${data.name} - The Grid` } }) );
                this.redirect(post_url(data.user.username, data.id));
							}
						}
					],
					// label: {
					// 	text: "AED " + data.price,
					// 	color: '#FFF',
					// 	fontSize: '12px',
					// 	fontWeight: 'normal',
					// }
				});
			}

      _authChange(auth) {
        if(!window.google) return;
        this.populateJobMarkers();
      }

      _initSocketEvents() {

        // when new post is posted
        socket.on('user:posted', data => {
          const _data = data;

          // assume that the post is not posted by the user connected
          _data.isMyPost = false;
          // check if user is loggedin and it is his post set isMyPost to true
          if(this.auth) {
            if(_data.user.id == this.user.id) {
              _data.isMyPost = true;
              // add it to the posts list
            }
          }

          this._newMarker(_data);

        });
      }


    }

    customElements.define(GridMap.is, GridMap);
	</script>
</dom-module>
