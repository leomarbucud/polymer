<link rel="import" href="../../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../../../../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../../../../bower_components/iron-icons/maps-icons.html">
<link rel="import" href="../../grid-styles.html">
<link rel="import" href="../../grid-icons.html">
<link rel="import" href="../../components/divider-text.html">

<dom-module id="grid-conversation">
  <template>
    <style include="grid iron-flex">
       :host {
        display: block;
        background: var(--dark-grey);
        height: 100%;
      }

      main {
        padding-bottom: 76px;
      }

      .chat {
        list-style-type: none;
        width: 100%;
        padding: 0;
      }

      .chat:after {
        content: ' ';
        display: block;
        height: 0;
        clear: both;
      }

      .chat-bubble {
        margin-bottom: 3px;
        padding: 5px 10px;
        clear: both;
        border-radius: 10px 10px 2px 2px;
        max-width: 90%;
      }

      .chat-date {
        clear: both;
      }

      .chat-bubble-rcvd {
        background: #f2f2f2;
        color: black;
        float: left;
        border-bottom-right-radius: 10px;
      }

      .chat-bubble-sent {
        /* background: #0066ff; */
        background: var(--red);
        color: white;
        float: right;
        border-bottom-left-radius: 10px;
      }

      .chat-bubble-sent + .chat-bubble-sent {
        border-top-right-radius: 2px;
      }

      .chat-bubble-rcvd + .chat-bubble-rcvd {
        border-top-left-radius: 2px;
      }

      .chat-bubble-stop {
        border-bottom-right-radius: 10px !important;
        border-bottom-left-radius: 10px !important;
      }

      .messages-wrapper {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        min-height: 100%;
      }

      #message-box {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: #424141;
        padding: 8px 16px;
      }

      img.circle {
        width: 32px;
        height: 32px;
      }

      .conversation-header {
        display: flex;
        align-items: center;
        justify-content: left;
      }

      .conversation-header .avatar {
        margin-right: 16px;
      }

      .typing-indicator-wr {
        position: absolute;
        bottom: 76px;
        left: 16px;
      }

      .typing-indicator {
        background-color: #f2f2f2;
        will-change: transform;
        width: auto;
        /* border-radius: 50px; */
        padding: 4px;
        display: table;
        /* margin: 0 auto; */
        /* margin-bottom: 16px; */
        position: relative;
        -webkit-animation: 2s bulge infinite ease-out;
        animation: 2s bulge infinite ease-out;
      }

      /* .typing-indicator::before,
      .typing-indicator::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: -2px;
        height: 10px;
        width: 10px;
        border-radius: 50%;
        background-color: #f2f2f2;
      }

      .typing-indicator::after {
        height: 5px;
        width: 5px;
        left: -5px;
        bottom: -5px;
      } */

      .typing-indicator span {
        height: 8px;
        width: 8px;
        float: left;
        margin: 0 1px;
        background-color: #9E9EA1;
        display: block;
        border-radius: 50%;
        opacity: 0.4;
      }

      .typing-indicator span:nth-of-type(1) {
        -webkit-animation: 1s blink infinite 0.3333s;
        animation: 1s blink infinite 0.3333s;
      }

      .typing-indicator span:nth-of-type(2) {
        -webkit-animation: 1s blink infinite 0.6666s;
        animation: 1s blink infinite 0.6666s;
      }

      .typing-indicator span:nth-of-type(3) {
        -webkit-animation: 1s blink infinite 0.9999s;
        animation: 1s blink infinite 0.9999s;
      }

      @-webkit-keyframes blink {
        50% {
          opacity: 1;
        }
      }

      @keyframes blink {
        50% {
          opacity: 1;
        }
      }

      @-webkit-keyframes bulge {
        50% {
          -webkit-transform: scale(1.05);
          transform: scale(1.05);
        }
      }

      @keyframes bulge {
        50% {
          -webkit-transform: scale(1.05);
          transform: scale(1.05);
        }
      }
    </style>

    <div id="toolbar" class="toolbar shadow">
      <paper-icon-button icon="chevron-left" class="red pointer" on-click="redirectInbox"></paper-icon-button>
      <div class="flex">
        <div class="conversation-header">
          <template is="dom-if" if="[[conversation.messages]]">
            <div class="avatar">
              <img class="circle" src$="[[_recipientProfileImage]]">
            </div>
            <span class="name white">[[_getRecipientName]]</span>
          </template>
        </div>
      </div>
    </div>

    <main class="scroll-area flex">
      <section class="messages-wrapper p-y-1">
        <div class="flex"></div>
        <ul id="chat" class="chat">
          <template id="messagesTemplate" is="dom-repeat" items="[[conversation.messages]]" as="message" sort="_sort">
            <li id$="[[message.id]]" class$="chat-bubble [[_getClass(message.author_id, index)]]" title="[[message.created_at]]" data-index$="[[index]]" data-author$="[[message.author_id]]">
              <span>[[message.message]]</span>
              <!-- <span class="status">[[_getMessageStatus(message.status)]]</span> -->
            </li>
            <!-- <template is="dom-if" if="[[!_sameAsDateBefore(message.created_at, index)]]">
              <li class="chat-date">
                <divider-text line-width="1px" line-color="#FFFFFF">
                  <span class="white">[[_fromNow(message.created_at)]]</span>
                </divider-text>
              </li>
            </template> -->
          </template>
          <template is="dom-if" if="[[_hasTmpMessage]]">
            <template is="dom-repeat" items="[[_tmpMessage]]" as="message">
              <li class="chat-bubble chat-bubble-sent">
                <small hidden$="[[!message.sending]]">
                  <paper-spinner active style="width: 12px; height: 12px;"></paper-spinner>
                </small>
                <span>[[message.message]]</span>
              </li>
            </template>
          </template>
          <template is="dom-if" if="[[isTyping]]">
            <li class="chat-bubble chat-bubble-rcvd typing">
              <div class="typing-indicator">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </li>
          </template>
        </ul>
      </section>

    </main>

    <div id="message-box">
      <section class="w-100">
        <form class="form">
          <div class="input-group suffix">
            <input id="message" type="text" class="input" autocomplete="off" placeholder="Type a message..." value="{{message::input}}"
              on-keydown="messageEvent" on-click="readMessage" />

            <div class="addon-suffix has-button">
              <paper-icon-button icon="grid:send" class="red" on-tap="send"></paper-icon-button>
            </div>
          </div>

        </form>
      </section>
    </div>

    <template is="dom-if" if="[[isLoading]]">
      <div class="overlay dgrey-bg" style="margin-top: 64px;">
        <div class="align-center">
          <paper-spinner active$="[[isLoading]]"></paper-spinner>
        </div>
      </div>
    </template>

  </template>

  <script>
    class GridConversation extends 
      GridNavigation(
        ReduxAsyncActionBehavior(
          ReduxBehavior(Polymer.Element))) {

      static get is() { return 'grid-conversation'; }

      static get properties() {
        return {
          user: {
            type: Object,
            statePath: 'user'
          },

          auth: {
            type: Boolean,
            statePath: 'auth'
          },

          inbox: {
            type: Object,
            statePath: 'inbox'
          },

        }
      }

      static get observers() {
        return [
          '_conversationIdChange(conversationId)',
          '_inboxChange(inbox)',
        ]
      }

      static get actions() {
        return {
          
        };
      }

      constructor() {
        super();
        this.isLoading = true;
        this.conversation = null;
        this._tmpMessage = [];
        this._hasTmpMessage = false;
        this._recipientProfileImage = this._profileImage(null, 'Grid');
        this.isTyping = false;

        this._initSocketEvents();
      }

      connectedCallback() {
        super.connectedCallback();

      }

      renderConversation(conversation, smooth = true) {
        if (!this.auth) return;

        // this.set('conversation', conversation);
        this.conversation = conversation;
        // console.log('new conversation', this.conversation);
        this._removeTmpMessage();
        this.shadowRoot.querySelector('#messagesTemplate').render();
        this.scrollToBottom(smooth);
        this.isLoading = false;
        this._recipientProfileImage = this._getRecipientProfileImage();
        this._getRecipientName = this._getRecipient().name;

        const chats = this.$.chat.querySelectorAll('li[data-index]');
        
        chats.forEach( (chat, i) => {

          chat.classList.remove('chat-bubble-stop');

          if(chats[i+1]) {
            if(chat.getAttribute('data-author') != chats[i+1].getAttribute('data-author')) {
              chat.classList.add('chat-bubble-stop');
            }
          }

          if(i == chats.length-1) {
            chat.classList.add('chat-bubble-stop');
          }
          
        });
      }

      scrollToBottom(smooth) {
        setTimeout(() => {

          const height = this.shadowRoot.querySelector('.messages-wrapper').scrollHeight;
          const elem = this.shadowRoot.querySelector('.scroll-area')
          
          elem.scrollTop = height;

          let scrollOptions = {
            top: height, 
            left: 0
          };

          if( smooth ) {
            scrollOptions.behavior = 'smooth' ;
          }

          elem.scroll(scrollOptions);


        }, 50);
      }

      send() {

        if (!this.auth || !this.message) return;

        var tmpMessage = {
          id: 'tmpMessage',
          message: this.message,
          created_at: new Date().getTime(),
          sending: true
        };

        this._createTmpMessage(tmpMessage);
        const m = this.message;

        this.message = '';

        gAxios.post('/users/' + this.user.id + '/conversations/' + this.conversationId, {
          message: m,
          recipient_id: this._getRecipientId()
        }).then(res => {
          var data = res.data;
          // this.dispatch('addMessage', this.conversationId, data);
          window.dispatchEvent(new CustomEvent('user:send_message', { detail: data }));
        }).catch(err => {

        }).then(() => {

          // this._removeTmpMessage();

        });

      }

      messageEvent(e) {
        const self = this;
        if (e.keyCode == 13) {
          this.send();
          e.preventDefault();
          return;
        }
        if (this.timeout) clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
          window.dispatchEvent(new CustomEvent('user:typing', {
            detail: {
              recipient_id: this._getRecipientId(),
              conversation_id: this.conversationId
            }
          }));
        }, 200);
      }

      readMessage(e) {
        if (!this.auth) return;

        if (this.conversation.last_updated_by == this.user.id || this.conversation.unread_count == 0) return;

        gAxios.post('/users/' + this.user.id + '/conversations/' + this.conversationId + '/read', {

        })
          .then(res => {
            var data = res.data;
            console.log(data);
            this.dispatch('updateConversation', this.conversationId, data);
            //this.message = '';
            //window.dispatchEvent(new CustomEvent('user:send_message', { detail: data }));
          })
          .catch(err => {

          });
      }

      _removeTmpMessage() {
        this.set('_tmpMessage', []);
        this._hasTmpMessage = false;
      }

      _getRecipientId() {
        if (this.conversation.user_id_1 == this.user.id) {
          return this.conversation.user_id_2;
        }

        return this.conversation.user_id_1;
      }

      _getRecipient() {
        return (this.conversation.user1.id == this._getRecipientId()) ? this.conversation.user1 : this.conversation.user2;
      }

      _getRecipientProfileImage() {
        const recipient = this._getRecipient();
        if (recipient.profile) {
          if (recipient.profile.profile_image_url)
            return this._profileImage(recipient.profile.profile_image_url, recipient.name);
        }

        return this._profileImage(null, recipient.name);

      }

      viewOnMap() {
        if (!this.bid && this.map) return;

        const job = this.bid.job;
        const position = new google.maps.LatLng(job.lat, job.lng);

        this.map.setCenter(position);
        this.map.setZoom(20);
        this.redirectHome();
      }

      _conversationIdChange(conversationId) {
        if (!conversationId) {
          this.conversation = [];
          return;
        }
        if (!this.auth) return;

        this.isLoading = true;
        this.inbox.map(conversation => {
          if (parseInt(conversation.id) === parseInt(conversationId)) {
            this.renderConversation(conversation, false);
            this.readMessage();
            this.isLoading = false;
          }
        });
      }

      _createTmpMessage(message) {
        this._hasTmpMessage = true;
        this.push('_tmpMessage', message);
        this.scrollToBottom(true);
      }

      _inboxChange(inbox) {
        this.inbox.map(conversation => {
          if (parseInt(conversation.id) === parseInt(this.conversationId)) {
            this.renderConversation(conversation);
            this.readMessage();
            this.isLoading = false;
          }
        });
      }

      _getMessageStatus(status) {
        return status;
      }

      _sort(a, b) {
        a = new Date(a.created_at);
        b = new Date(b.created_at);
        return b > a ? -1 : b < a ? 1 : 0;
      }

      _getClass(id, index) {
        // if (this.i != id) {
        //   this.i = id;
        //   var li = this.$.chat.querySelector('li[data-index="' + (index - 1) + '"]');
        //   if (li) {
        //     li.classList.add('chat-bubble-stop');
        //   }
        // }
        if (this.user.id == id) {
          return 'chat-bubble-sent';
        } else {
          return 'chat-bubble-rcvd';
        }
      }

      _sameAsDateBefore(date, index) {
        var endDate = moment(date, "YYYY-MM-DD");
        var diff = 0;
        var li = this.$.chat.querySelector('li[data-index="' + (index - 1) + '"]');
        if(li) {
          var startDate = moment(li.getAttribute('title'), "YYYY-MM-DD");

          diff = Math.abs(startDate.diff(endDate, 'days'));
          console.log(index, diff);
        }

        return (diff === 0) ? true : false;
      }

      _fromNow(date) {
        return moment(date).fromNow();
      }

      _profileImage(img, name) {
        if (img) {
          return this.url.API_BASE_URL + '/uploads/' + img;
        }
        return LetterAvatar(name, '32');

      }

      _details(details) {
        if (details) return details;

        return 'No details provided.';
      }

      _initSocketEvents() {

        // when user receive message
        socket.on('user:receive_message', data => {
          if(!this.auth) return;
          this.isTyping = false;
        });


        var userTyping;
        // when user is typing
        socket.on('user:typing', data => {
          if (!data) return;
          if (data.conversation_id == this.conversationId) {
            this.isTyping = true;
            this.scrollToBottom();
            if (userTyping) clearTimeout(userTyping);
            userTyping = setTimeout(() => {
              this.isTyping = false;
            }, 8000);
          }
        });

      }

    }

    customElements.define(GridConversation.is, GridConversation);
  </script>
</dom-module>